From: http://libmtp.git.sf.net/git/gitweb.cgi?p=libmtp/libmtp;a=commitdiff;h=4950c02db9a9ac0f519ff095c7290c9b56f14b44;hp=5ab67476d2a5af47e321a42762367cc612b100f0
Description: Add recovery from broken object info.
---
 src/device-flags.h |    6 ++++-
 src/ptp.c          |   61 +++++++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 66 insertions(+), 1 deletion(-)

--- libmtp.orig/src/device-flags.h
+++ libmtp/src/device-flags.h
@@ -273,7 +273,11 @@
  * if you try to get individual properties of an object.
  */
 #define DEVICE_FLAG_BROKEN_GET_OBJECT_PROPVAL	0x20000000
-
+/**
+ * It seems that some devices return an bad data when
+ * using the GetObjectInfo operation.
+ */
+#define DEVICE_FLAG_BROKEN_GET_OBJECT_INFO	0x40000000
 
 /**
  * All these bug flags need to be set on SONY NWZ Walkman
--- libmtp.orig/src/ptp.c
+++ libmtp/src/ptp.c
@@ -5339,6 +5339,10 @@ ptp_object_want (PTPParams *params, uint
 	PTPObject	*ob;
 	/*Camera 		*camera = ((PTPData *)params->data)->camera;*/
 
+	/* If GetObjectInfo is broken, force GetPropList */
+	if (params->device_flags & DEVICE_FLAG_BROKEN_GET_OBJECT_INFO)
+		want |= PTPOBJECT_MTPPROPLIST_LOADED;
+
 	*retob = NULL;
 	if (!handle) {
 		ptp_debug (params, "ptp_object_want: querying handle 0?\n");
@@ -5401,6 +5405,63 @@ ptp_object_want (PTPParams *params, uint
 		ob->mtpprops = props;
 		ob->nrofmtpprops = nrofprops;
 
+		/* Override the ObjectInfo data with data from properties */
+		if (params->device_flags & DEVICE_FLAG_BROKEN_GET_OBJECT_INFO) {
+			int i;
+			MTPProperties *prop = ob->mtpprops;
+
+			for (i=0;i<ob->nrofmtpprops;i++,prop++) {
+				switch (prop->property) {
+				case PTP_OPC_StorageID:
+				  ob->oi.StorageID = prop->propval.u32;
+				  break;
+				case PTP_OPC_ObjectFormat:
+				  ob->oi.ObjectFormat = prop->propval.u16;
+				  break;
+				case PTP_OPC_ProtectionStatus:
+				  ob->oi.ProtectionStatus = prop->propval.u16;
+				  break;
+				case PTP_OPC_ObjectSize:
+				  if (prop->datatype == PTP_DTC_UINT64) {
+					if (prop->propval.u64 > 0xFFFFFFFFU)
+						ob->oi.ObjectCompressedSize = 0xFFFFFFFFU;
+					else
+						ob->oi.ObjectCompressedSize = (uint32_t)prop->propval.u64;
+				  } else if (prop->datatype == PTP_DTC_UINT32) {
+					ob->oi.ObjectCompressedSize = prop->propval.u32;
+				  }
+				  break;
+				case PTP_OPC_AssociationType:
+				  ob->oi.AssociationType = prop->propval.u16;
+				  break;
+				case PTP_OPC_AssociationDesc:
+				  ob->oi.AssociationDesc = prop->propval.u32;
+				  break;
+				case PTP_OPC_ObjectFileName:
+				  if (prop->propval.str) {
+					  free(ob->oi.Filename);
+					  ob->oi.Filename = strdup(prop->propval.str);
+				  }
+				  break;
+				case PTP_OPC_DateCreated:
+				  ob->oi.CaptureDate = ptp_unpack_PTPTIME(prop->propval.str);
+				  break;
+				case PTP_OPC_DateModified:
+				  ob->oi.ModificationDate = ptp_unpack_PTPTIME(prop->propval.str);
+				  break;
+				case PTP_OPC_Keywords:
+				  if (prop->propval.str) {
+					  free(ob->oi.Keywords);
+					  ob->oi.Keywords = strdup(prop->propval.str);
+				  }
+				  break;
+				case PTP_OPC_ParentObject:
+				  ob->oi.ParentObject = prop->propval.u32;
+				  break;
+				}
+			}
+		}
+
 #if 0
 		MTPProperties 	*xpl;
 		int j;
